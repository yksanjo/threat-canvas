import PDFDocument from 'pdfkit';
import { ExportRequest, STRIDEThreat, AttackTree } from '../types';

export class ExportHandler {
  async exportToPDF(request: ExportRequest): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const chunks: Buffer[] = [];
        const doc = new PDFDocument({ margin: 50 });

        doc.on('data', (chunk) => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Title Page
        this.addTitlePage(doc, request);

        // System Architecture
        this.addArchitectureSection(doc, request);

        // STRIDE Analysis
        this.addSTRIDESection(doc, request.threats);

        // Attack Trees
        if (request.attackTrees && request.attackTrees.length > 0) {
          this.addAttackTreeSection(doc, request.attackTrees);
        }

        // Risk Summary
        this.addRiskSummary(doc, request.threats);

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  exportToJSON(request: ExportRequest): object {
    return {
      title: request.title,
      author: request.author || 'Anonymous',
      exportedAt: new Date().toISOString(),
      version: '1.0.0',
      architecture: {
        nodes: request.nodes,
        edges: request.edges,
      },
      threats: request.threats,
      attackTrees: request.attackTrees,
      summary: {
        totalNodes: request.nodes.length,
        totalEdges: request.edges.length,
        totalThreats: request.threats.length,
        criticalThreats: request.threats.filter(t => t.severity === 'Critical').length,
        highThreats: request.threats.filter(t => t.severity === 'High').length,
        riskScore: this.calculateRiskScore(request.threats),
      },
    };
  }

  private addTitlePage(doc: PDFKit.PDFDocument, request: ExportRequest): void {
    // Header with styling
    doc.rect(0, 0, doc.page.width, 150).fill('#0a0a0a');
    
    doc.fillColor('#00d4ff')
      .fontSize(32)
      .font('Helvetica-Bold')
      .text('THREAT CANVAS', 50, 60, { align: 'center' });

    doc.fillColor('#ffffff')
      .fontSize(24)
      .font('Helvetica-Bold')
      .text(request.title, 50, 200, { align: 'center' });

    doc.fillColor('#888888')
      .fontSize(14)
      .font('Helvetica')
      .text(`Generated by ${request.author || 'Anonymous'}`, 50, 250, { align: 'center' })
      .text(new Date().toLocaleDateString(), 50, 270, { align: 'center' });

    doc.addPage();
  }

  private addArchitectureSection(doc: PDFKit.PDFDocument, request: ExportRequest): void {
    doc.fillColor('#00d4ff')
      .fontSize(20)
      .font('Helvetica-Bold')
      .text('System Architecture', 50, 50);

    doc.fillColor('#888888')
      .fontSize(12)
      .font('Helvetica')
      .text(`Total Components: ${request.nodes.length} | Connections: ${request.edges.length}`, 50, 80);

    // Node list
    doc.moveDown(2);
    doc.fillColor('#ffffff')
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Components:', 50, doc.y);

    request.nodes.forEach((node, index) => {
      doc.moveDown(0.5);
      doc.fillColor('#cccccc')
        .fontSize(11)
        .font('Helvetica')
        .text(`${index + 1}. ${node.label} (${node.type})`, 70, doc.y);
      if (node.data.description) {
        doc.fillColor('#888888')
          .text(`   ${node.data.description}`, 70, doc.y);
      }
    });

    // Connections
    doc.moveDown(2);
    doc.fillColor('#ffffff')
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Data Flows:', 50, doc.y);

    request.edges.forEach((edge, index) => {
      doc.moveDown(0.5);
      const sourceNode = request.nodes.find(n => n.id === edge.source);
      const targetNode = request.nodes.find(n => n.id === edge.target);
      doc.fillColor('#cccccc')
        .fontSize(11)
        .text(`${index + 1}. ${sourceNode?.label || edge.source} → ${targetNode?.label || edge.target}${edge.label ? ` (${edge.label})` : ''}`, 70, doc.y);
    });

    doc.addPage();
  }

  private addSTRIDESection(doc: PDFKit.PDFDocument, threats: STRIDEThreat[]): void {
    doc.fillColor('#00d4ff')
      .fontSize(20)
      .font('Helvetica-Bold')
      .text('STRIDE Threat Analysis', 50, 50);

    const categories: Record<string, STRIDEThreat[]> = {
      Spoofing: [],
      Tampering: [],
      Repudiation: [],
      InformationDisclosure: [],
      DenialOfService: [],
      ElevationOfPrivilege: [],
    };

    threats.forEach(threat => {
      if (categories[threat.category]) {
        categories[threat.category].push(threat);
      }
    });

    let yPos = 100;

    Object.entries(categories).forEach(([category, categoryThreats]) => {
      if (categoryThreats.length === 0) return;

      // Check if we need a new page
      if (yPos > 700) {
        doc.addPage();
        yPos = 50;
      }

      const categoryColors: Record<string, string> = {
        Spoofing: '#ff6b35',
        Tampering: '#ff1744',
        Repudiation: '#ffa726',
        InformationDisclosure: '#9d4edd',
        DenialOfService: '#00d4ff',
        ElevationOfPrivilege: '#00ff88',
      };

      doc.fillColor(categoryColors[category] || '#ffffff')
        .fontSize(16)
        .font('Helvetica-Bold')
        .text(category.replace(/([A-Z])/g, ' $1').trim(), 50, yPos);

      yPos += 30;

      categoryThreats.forEach((threat, index) => {
        if (yPos > 700) {
          doc.addPage();
          yPos = 50;
        }

        const severityColors: Record<string, string> = {
          Low: '#4caf50',
          Medium: '#ff9800',
          High: '#f44336',
          Critical: '#9c27b0',
        };

        // Threat header
        doc.fillColor(severityColors[threat.severity])
          .fontSize(12)
          .font('Helvetica-Bold')
          .text(`${index + 1}. [${threat.severity}]`, 70, yPos);

        doc.fillColor('#cccccc')
          .fontSize(11)
          .font('Helvetica')
          .text(threat.description, 150, yPos, { width: 400 });

        yPos += 40;

        // Mitigation
        doc.fillColor('#888888')
          .fontSize(10)
          .font('Helvetica-Oblique')
          .text(`Mitigation: ${threat.mitigation}`, 90, yPos, { width: 460 });

        yPos += 25;

        // MITRE techniques
        if (threat.mitreTechniques.length > 0) {
          doc.fillColor('#00d4ff')
            .fontSize(10)
            .font('Helvetica')
            .text(`MITRE: ${threat.mitreTechniques.join(', ')}`, 90, yPos);
          yPos += 20;
        }

        yPos += 10;
      });

      yPos += 20;
    });

    doc.addPage();
  }

  private addAttackTreeSection(doc: PDFKit.PDFDocument, attackTrees: AttackTree[]): void {
    doc.fillColor('#00d4ff')
      .fontSize(20)
      .font('Helvetica-Bold')
      .text('Attack Tree Analysis', 50, 50);

    attackTrees.forEach((tree, treeIndex) => {
      if (treeIndex > 0) doc.addPage();

      const rootNode = tree.nodes[tree.rootNodeId];
      if (rootNode) {
        doc.fillColor('#ffffff')
          .fontSize(16)
          .font('Helvetica-Bold')
          .text(`Attack Tree ${treeIndex + 1}: ${rootNode.label}`, 50, 100);

        doc.fillColor('#888888')
          .fontSize(11)
          .font('Helvetica')
          .text(rootNode.description, 50, 130, { width: 500 });

        // Simple tree visualization
        this.renderAttackTreeNode(doc, tree, rootNode, 50, 180, 0);
      }
    });

    doc.addPage();
  }

  private renderAttackTreeNode(
    doc: PDFKit.PDFDocument,
    tree: AttackTree,
    node: AttackTree['nodes'][string],
    x: number,
    y: number,
    depth: number
  ): number {
    let currentY = y;

    // Node styling based on type
    const typeColors: Record<string, string> = {
      goal: '#ff1744',
      subgoal: '#ff6b35',
      technique: '#00d4ff',
      countermeasure: '#00ff88',
    };

    // Draw node
    doc.fillColor(typeColors[node.type] || '#ffffff')
      .fontSize(11 - depth)
      .font('Helvetica-Bold')
      .text(`${'  '.repeat(depth)}• ${node.label} [${node.difficulty}/${node.likelihood}/${node.impact}]`, x + (depth * 20), currentY);

    currentY += 20;

    // Recursively render children
    node.children.forEach(childId => {
      const childNode = tree.nodes[childId];
      if (childNode) {
        currentY = this.renderAttackTreeNode(doc, tree, childNode, x, currentY, depth + 1);
      }
    });

    return currentY;
  }

  private addRiskSummary(doc: PDFKit.PDFDocument, threats: STRIDEThreat[]): void {
    doc.fillColor('#00d4ff')
      .fontSize(20)
      .font('Helvetica-Bold')
      .text('Risk Summary', 50, 50);

    const riskScore = this.calculateRiskScore(threats);
    const criticalCount = threats.filter(t => t.severity === 'Critical').length;
    const highCount = threats.filter(t => t.severity === 'High').length;
    const mediumCount = threats.filter(t => t.severity === 'Medium').length;
    const lowCount = threats.filter(t => t.severity === 'Low').length;

    // Risk score visualization
    const scoreColor = riskScore >= 70 ? '#ff1744' : riskScore >= 40 ? '#ff9800' : '#4caf50';

    doc.fillColor(scoreColor)
      .fontSize(48)
      .font('Helvetica-Bold')
      .text(riskScore.toString(), 50, 100);

    doc.fillColor('#888888')
      .fontSize(14)
      .font('Helvetica')
      .text('/100 Risk Score', 120, 120);

    // Summary stats
    doc.moveDown(4);
    doc.fillColor('#ffffff')
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Threat Summary:', 50, 180);

    const stats = [
      { label: 'Critical', count: criticalCount, color: '#9c27b0' },
      { label: 'High', count: highCount, color: '#f44336' },
      { label: 'Medium', count: mediumCount, color: '#ff9800' },
      { label: 'Low', count: lowCount, color: '#4caf50' },
    ];

    let yPos = 210;
    stats.forEach(stat => {
      doc.fillColor(stat.color)
        .fontSize(12)
        .font('Helvetica-Bold')
        .text(`${stat.count}`, 70, yPos);
      
      doc.fillColor('#cccccc')
        .fontSize(12)
        .font('Helvetica')
        .text(stat.label, 100, yPos);

      yPos += 25;
    });

    // Footer
    doc.fillColor('#555555')
      .fontSize(10)
      .font('Helvetica')
      .text('Generated by Threat Canvas - AI-Powered Threat Modeling Tool', 50, 750, { align: 'center' });
  }

  private calculateRiskScore(threats: STRIDEThreat[]): number {
    if (threats.length === 0) return 0;
    
    const severityWeights: Record<string, number> = {
      Low: 20,
      Medium: 40,
      High: 70,
      Critical: 100,
    };

    const totalWeight = threats.reduce((sum, t) => sum + severityWeights[t.severity], 0);
    return Math.round(totalWeight / threats.length);
  }
}
